<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First-Person Movement Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #gun-image {
            position: fixed;
            bottom: 0px; /* Adjust the distance from the bottom */
            right: 0px; /* Adjust the distance from the right */
            width: 600px; /* Adjust the width of the image */
            height: auto; /* Maintain aspect ratio */
            z-index: 9999; /* Ensure the image appears on top of other elements */
            pointer-events: none; /* Disable pointer events on the image */
        }
    </style>
</head>
<body>
    <img src="https://imagetolink.com/ib/l7HJVSO1yy.png" id="gun-image">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            // Set up Three.js scene
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create a cube as our platform
            const platformGeometry = new THREE.BoxGeometry(10, 1, 10);
            const platformMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            scene.add(platform);

            // Create a red target
            const targetGeometry = new THREE.BoxGeometry(1, 1, 1);
            const targetMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            scene.add(target);

            // Position the target
            target.position.set(0, 2, -5); // Adjust the position as needed

            // Create a particle system
            const particleGeometry = new THREE.BufferGeometry(); // Use BufferGeometry
            const vertices = [];
            const particleMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);

            // Initialize camera position
            camera.position.set(0, 1.5, 5);

            // Initialize mouse movement variables
            let isDragging = false;
            let previousMouseX = 0;

            // Keyboard state
            const keyboardState = {
                'w': false,
                's': false,
                'a': false,
                'd': false
            };

            // Keyboard event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // Handle mouse movement for turning
            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Handle shooting particles on left mouse button click
            document.addEventListener('mousedown', handleShootParticles);

            // Prevent default context menu
            document.addEventListener('contextmenu', function(event) {
                event.preventDefault();
            });

            // Main loop
            function animate() {
                requestAnimationFrame(animate);

                // Update camera position based on user input
                const movementSpeed = 0.1;

                // Move forward/backward and left/right relative to camera orientation
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

                if (keyboardState['w']) camera.position.add(forward.clone().multiplyScalar(movementSpeed));
                if (keyboardState['s']) camera.position.add(forward.clone().multiplyScalar(-movementSpeed));
                if (keyboardState['a']) camera.position.add(right.clone().multiplyScalar(-movementSpeed));
                if (keyboardState['d']) camera.position.add(right.clone().multiplyScalar(movementSpeed));

                renderer.render(scene, camera);
            }

            animate();

            // Event handlers
            function handleKeyDown(event) {
                if (event.key in keyboardState) {
                    keyboardState[event.key] = true;
                }
            }

            function handleKeyUp(event) {
                if (event.key in keyboardState) {
                    keyboardState[event.key] = false;
                }
            }

            function handleMouseDown(event) {
                if (event.button === 2) { // Check if right mouse button is clicked
                    isDragging = true;
                    previousMouseX = event.clientX;
                }
            }

            function handleMouseMove(event) {
                if (!isDragging) return;
                const delta = event.clientX - previousMouseX;
                camera.rotation.y += (delta * 0.01);
                previousMouseX = event.clientX;
            }

            function handleMouseUp(event) {
                if (event.button === 2) { // Check if right mouse button is released
                    isDragging = false;
                    event.preventDefault(); // Prevent default context menu
                }
            }

            function handleShootParticles(event) {
    if (event.button === 2) { // Check if right mouse button is clicked
        const particleCount = 50;
        const positions = [];
        const direction = new THREE.Vector3();
        
        // Calculate direction based on camera orientation
        camera.getWorldDirection(direction);

        for (let i = 0; i < particleCount; i++) {
            positions.push(
                camera.position.x, // Start particles from camera position
                camera.position.y, // Start particles from camera position
                camera.position.z // Start particles from camera position
            );
            // Add some randomness to the direction to spread out particles
            const spread = 0.1;
            const spreadVector = new THREE.Vector3(
                (Math.random() - 0.5) * spread,
                (Math.random() - 0.5) * spread,
                (Math.random() - 0.5) * spread
            );
            const particleDirection = direction.clone().add(spreadVector);
            positions.push(
                particleDirection.x, // X
                particleDirection.y, // Y
                particleDirection.z // Z
            );
        }
        particleSystem.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    }
}


        });
    </script>
</body>
</html>
