<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First-Person Movement Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #gun-image {
            position: fixed;
            bottom: -50px; /* Adjust the distance from the bottom */
            right: -100px; /* Adjust the distance from the right */
            width: 400px; /* Adjust the width of the image */
            height: auto; /* Maintain aspect ratio */
            z-index: 9999; /* Ensure the image appears on top of other elements */
            pointer-events: none; /* Disable pointer events on the image */
            user-select: none; /* Disable text selection */
            -webkit-touch-callout: none; /* Disable touch callout on iOS Safari */
            -webkit-user-select: none; /* Disable text selection on iOS Safari */
            -moz-user-select: none; /* Disable text selection on Firefox */
            -ms-user-select: none; /* Disable text selection on Internet Explorer/Edge */
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid #fff;
            border-radius: 50%;
            box-sizing: border-box;
            pointer-events: none;
        }
        #crosshair::after, #crosshair::before {
            content: '';
            position: absolute;
            width: 50%;
            height: 2px;
            background-color: #fff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #crosshair::after {
            transform: translate(-50%, -50%) rotate(90deg);
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <img src="https://imagetolink.com/ib/g5qa0vmqby.png" id="gun-image">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
    // Set up Three.js scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a cube as our platform
    const platformGeometry = new THREE.BoxGeometry(10, 1, 10);
    const platformMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
    scene.add(platform);

    // Create a red target
    const targetGeometry = new THREE.BoxGeometry(1, 1, 1);
    const targetMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const target = new THREE.Mesh(targetGeometry, targetMaterial);
    scene.add(target);

    // Position the target
    target.position.set(0, 2, -5); // Adjust the position as needed

    // Initialize camera position
    camera.position.set(0, 1.5, 5);
    
    // Create a camera helper that will determine direction
    // This is a simple way to manage the yaw and pitch without gimbal lock issues
    const cameraHolder = new THREE.Object3D();
    scene.add(cameraHolder);
    cameraHolder.position.set(0, 1.5, 5);
    cameraHolder.add(camera);
    camera.position.set(0, 0, 0); // Camera is now at the center of cameraHolder

    // Keyboard state
    const keyboardState = {
        'w': false,
        's': false,
        'a': false,
        'd': false
    };

    // Mouse controls
    const mouseSensitivity = 0.002;
    let isMouseDown = false;
    let previousMouseX = 0;
    let previousMouseY = 0;
    
    // Prevent mouse from getting too high or too low
    let pitchObject = new THREE.Object3D();
    cameraHolder.add(pitchObject);
    pitchObject.add(camera);
    
    // Shooting state
    let isShooting = false;

    // Array to hold particles
    const particles = [];

    // Keyboard event listeners
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);

    // Mouse event listeners
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    // Lock pointer on canvas click for better FPS controls
    renderer.domElement.addEventListener('click', function() {
        renderer.domElement.requestPointerLock();
    });

    // Prevent default context menu
    document.addEventListener('contextmenu', function(event) {
        event.preventDefault();
    });

    // Main loop
    function animate() {
        requestAnimationFrame(animate);

        // Update camera position based on user input
        const movementSpeed = 0.1;

        // Get direction vectors from the cameraHolder's orientation
        const forwardVector = new THREE.Vector3(0, 0, -1);
        forwardVector.applyQuaternion(cameraHolder.quaternion);
        forwardVector.y = 0; // Keep movement on the xz plane
        forwardVector.normalize();
        
        const rightVector = new THREE.Vector3(1, 0, 0);
        rightVector.applyQuaternion(cameraHolder.quaternion);
        rightVector.y = 0; // Keep movement on the xz plane
        rightVector.normalize();

        // Calculate movement based on keys pressed
        const moveDirection = new THREE.Vector3(0, 0, 0);
        
        if (keyboardState['w']) moveDirection.add(forwardVector);
        if (keyboardState['s']) moveDirection.sub(forwardVector);
        if (keyboardState['a']) moveDirection.sub(rightVector);
        if (keyboardState['d']) moveDirection.add(rightVector);
        
        // Only apply movement if there's input
        if (moveDirection.length() > 0) {
            moveDirection.normalize(); // Normalize to prevent faster diagonal movement
            cameraHolder.position.add(moveDirection.multiplyScalar(movementSpeed));
        }
        
        // Ensure player stays above the floor
        if (cameraHolder.position.y < 1.5) {
            cameraHolder.position.y = 1.5;
        }

        // If shooting, create a particle effect
        if (isShooting) {
            createParticleEffect();
            isShooting = false;
        }

        // Update particle positions and remove them if they travel too far
        for (let i = particles.length - 1; i >= 0; i--) {
            const particle = particles[i];
            particle.position.add(particle.userData.velocity);
            
            if (particle.position.distanceTo(particle.userData.initialPosition) > 50) {
                scene.remove(particle);
                particles.splice(i, 1);
            }
        }

        renderer.render(scene, camera);
    }

    animate();

    // Event handlers
    function handleKeyDown(event) {
        if (event.key.toLowerCase() in keyboardState) {
            keyboardState[event.key.toLowerCase()] = true;
        }
    }

    function handleKeyUp(event) {
        if (event.key.toLowerCase() in keyboardState) {
            keyboardState[event.key.toLowerCase()] = false;
        }
    }

    function handleMouseDown(event) {
        if (event.button === 0) { // Left mouse button
            isShooting = true;
        } else if (event.button === 2) { // Right mouse button
            isMouseDown = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }
    }

    function handleMouseMove(event) {
        if (document.pointerLockElement === renderer.domElement) {
            // Pointer lock controls (modern first-person control)
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            // Rotate cameraHolder (yaw) for left-right movement
            cameraHolder.rotation.y -= movementX * mouseSensitivity;
            
            // Rotate camera (pitch) for up-down movement
            pitchObject.rotation.x -= movementY * mouseSensitivity;
            
            // Limit the up-down rotation to prevent flipping
            pitchObject.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitchObject.rotation.x));
        } 
        else if (isMouseDown) {
            // Traditional mouse drag controls
            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;
            
            // Rotate cameraHolder (yaw) for left-right movement
            cameraHolder.rotation.y -= deltaX * mouseSensitivity * 5;
            
            // Rotate camera (pitch) for up-down movement
            pitchObject.rotation.x -= deltaY * mouseSensitivity * 5;
            
            // Limit the up-down rotation to prevent flipping
            pitchObject.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitchObject.rotation.x));
            
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }
    }

    function handleMouseUp(event) {
        if (event.button === 2) { // Right mouse button released
            isMouseDown = false;
        }
    }

    function createParticleEffect() {
        const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        
        // Position particle at camera position
        particle.position.copy(camera.getWorldPosition(new THREE.Vector3()));
        scene.add(particle);
        particles.push(particle);

        // Get direction from camera
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
        
        const speed = 0.5;
        particle.userData.velocity = direction.multiplyScalar(speed);
        particle.userData.initialPosition = particle.position.clone();

        const gravity = new THREE.Vector3(0, -0.01, 0);
        const timeStep = 0.000001;

        // Simulate bullet drop
        const dropInterval = setInterval(() => {
            if (particles.indexOf(particle) === -1) {
                clearInterval(dropInterval);
                return;
            }
            
            particle.userData.velocity.add(gravity.clone().multiplyScalar(timeStep));
            particle.position.add(particle.userData.velocity.clone().multiplyScalar(timeStep));
            
            if (particle.position.y <= 0) {
                clearInterval(dropInterval);
                scene.remove(particle);
                const index = particles.indexOf(particle);
                if (index !== -1) {
                    particles.splice(index, 1);
                }
            }
        }, timeStep * 1000);
    }
});
    </script>
</body>
</html>
